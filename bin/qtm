#!/usr/bin/env bash
set -euo pipefail
# ----------------------------
# Global flags (non-breaking extension)
# ----------------------------
JSON_ONLY=0

# Allow --json either before the command or after it (probe --json)
# We parse a leading --json first; later we also check per-command args.
if [[ "${1:-}" == "--json" ]]; then
  JSON_ONLY=1
  shift
fi

# ----------------------------
# QTM Macro (FROZEN): prints on every invocation
# ----------------------------
# ----------------------------
# QTM Macro (FROZEN): prints on every invocation
# ----------------------------
if [[ "$JSON_ONLY" -eq 0 ]]; then
  cat <<'BANNER'
QQQQQQQQQQQQQ    TTTTTTTTTTTTTTTTTT     MMMM           MMMM
QQ         QQ            TTT            MMMMMM        MMMMM
QQ         QQ            TTT            MM  MMMM    MMMM MM
QQ         QQ            TTT            MM    MMMM MMMM  MM
QQ         QQ            TTT            MM      MMMM     MM
QQ   QQQ   QQ            TTT            MM               MM
QQ     Q   QQ            TTT            MM               MM
QQ      QQQQ             TTT            MM               MM
 QQQQQQQQQ QQ            TTT            MM               MM
            QQQ
BANNER
fi

# ----------------------------
# Deterministic outputs (no env/time/network)
# ----------------------------

print_help() {
  cat <<'HELP_EOF'
QTM CLI v0.01 (QTM OS)

Usage:
  qtm [--help|--version|--spec] <command> [args]

Global Flags:
  --help        Print help and exit
  --version     Print runtime version header and exit
  --spec        Print CLI spec references and exit
  --json        Emit JSON only (suppresses macro/banner)


Commands (reserved namespaces):
  help          Print help and exit
  version       Print runtime version header and exit
  inspect       Read-only inspection (no validation, no mutation)
  runtime       Reserved namespace (no mutation at v0.01)
  surface       Reserved namespace (no surface load/start at v0.01)
  probe         Dry-run OS baseline test (no network, no execution)

Notes:
  - No authority is inferred.
  - No background services are started.
  - No Planck/OMNI/surface dependency.
HELP_EOF
}

print_spec_refs() {
  cat <<'SPEC_EOF'
CLI Specs (repo paths):
  - docs/cli/QTM_CLI_SKELETON_v0.01.md
  - docs/cli/QTM_RUNTIME_VERSION_HEADER_v0.01.md
  - docs/cli/QTM_OS_DEPLOYMENT_DRILL_CHECKLIST_v0.01.md
  - docs/cli/QTM_SURFACE_KILL_TEST_v0.01.md
  - docs/cli/CLI_TO_RUNTIME_MAPPING_v0.01.md
  - docs/cli/QTM_CLI_FREEZE_MANIFEST_v0.01.md
SPEC_EOF
}

print_runtime_header() {
  cat <<'RUNTIME_EOF'
QTM Runtime v0.01
Layer: QTM OS
Frozen Components:
  - QTM_MACRO_v0.01
  - QTM_CLI_SKELETON_v0.01
  - QTM_OS_DEPLOYMENT_DRILL_CHECKLIST_v0.01
  - QTM_SURFACE_KILL_TEST_v0.01
  - CLI_TO_RUNTIME_MAPPING_v0.01
  - QTM_CLI_FREEZE_MANIFEST_v0.01
  - QTM_RUNTIME_VERSION_HEADER_v0.01
Build Reference: git:@QTM_BUILD_REF@
Declaration: Non-authoritative, declarative runtime header
RUNTIME_EOF
}

# ----------------------------
# Minimal dispatcher (v0.01): no-op routing only
# ----------------------------
cmd="${1:-}"

case "$cmd" in
  ""|--help|help)
    print_help
    exit 0
    ;;

  --spec)
    print_spec_refs
    exit 0
    ;;

  --version|version)
    print_runtime_header
    exit 0
    ;;

  inspect)
    # Read-only. No validation. No mutation.
    cat <<'INSPECT_EOF'
qtm inspect (v0.01)
- Mode: read-only
- Notes: no validation, no mutation, no surfaces, no Planck, no OMNI
INSPECT_EOF
    exit 0
    ;;

  runtime)
    # Reserved namespace: no mutation at v0.01
    cat <<'RUNTIME_CMD_EOF'
qtm runtime (v0.01)
- Reserved namespace
- No mutation permitted at v0.01
RUNTIME_CMD_EOF
    exit 0
    ;;

  surface)
    # PLANCK Surface discovery (v0.01a): read-only, deterministic, filesystem-only
    sub="${2:-}"

    case "$sub" in
      ""|--help|help)
        cat <<'SURFACE_HELP_EOF'
qtm surface (v0.01a)
Subcommands:
  list        List available surfaces (read-only, Planck filesystem inspection only)

Notes:
  - No surface load/start
  - No OMNI calls
  - No network
  - Deterministic output
SURFACE_HELP_EOF
        exit 0
        ;;

      list)
        # Allow `qtm surface list --json` as well (in addition to global --json)
        if [[ "${3:-}" == "--json" ]]; then JSON_ONLY=1; fi

        # Surface presence rule: a surface is present iff both exist:
        #   planck/<NAME>_SPEC_v*.md
        #   planck/<NAME>_FREEZE_MANIFEST_v*.md
        #
        # Output:
        #  - human: stable text list
        #  - json: schema-enforced by contracts/CLI_OUTPUT_SCHEMA_v0.01a.json

        declare -A has_spec
        declare -A has_manifest
        declare -A names

        shopt -s nullglob
        for f in planck/*_SPEC_v*.md; do
          base="$(basename "$f")"
          name="${base%%_SPEC_v*}"
          name_lc="$(printf "%s" "$name" | tr '[:upper:]' '[:lower:]')"
          has_spec["$name_lc"]=1
          names["$name_lc"]=1
        done

        for f in planck/*_FREEZE_MANIFEST_v*.md; do
          base="$(basename "$f")"
          name="${base%%_FREEZE_MANIFEST_v*}"
          name_lc="$(printf "%s" "$name" | tr '[:upper:]' '[:lower:]')"
          has_manifest["$name_lc"]=1
          names["$name_lc"]=1
        done
        shopt -u nullglob

        # Collect present surfaces only (spec + manifest)
        present=()
        for n in "${!names[@]}"; do
          if [[ "${has_spec[$n]:-0}" -eq 1 && "${has_manifest[$n]:-0}" -eq 1 ]]; then
            present+=("$n")
          fi
        done

        # Deterministic sort
        IFS=$'\n' present_sorted=($(printf "%s\n" "${present[@]}" | LC_ALL=C sort))
        unset IFS

        if [[ "$JSON_ONLY" -eq 1 ]]; then
          # JSON (v0.01a)
          printf '{\n'
          printf '  "spec_version": "v0.01a",\n'
          printf '  "command": "surface.list",\n'
          printf '  "ok": true,\n'
          printf '  "result": {\n'
          printf '    "surfaces": [\n'

          first=1
          for n in "${present_sorted[@]}"; do
            if [[ -z "$n" ]]; then continue; fi
            if [[ "$first" -eq 0 ]]; then printf ',\n'; fi
            first=0
            printf '      { "name": "%s", "present": true, "frozen": true }' "$n"
          done

          printf '\n'
          printf '    ]\n'
          printf '  }\n'
          printf '}\n'
        else
          # Human text (v0.01a)
          echo "SURFACES (v0.01a)"
          for n in "${present_sorted[@]}"; do
            if [[ -z "$n" ]]; then continue; fi
            echo "- $n   [present, frozen]"
          done
        fi

        exit 0
        ;;

      *)
        echo "qtm surface: unknown subcommand: $sub" >&2
        echo "qtm surface: run 'qtm surface help' for usage" >&2
        exit 2
        ;;
    esac
    ;;

  probe)
    if [[ "${2:-}" == "--json" ]]; then JSON_ONLY=1; fi
    # QTM PROBE (v0.01a): dry-run baseline
    # MUST: deterministic output, no env/time/network, no execution

    OMNI_PRESENT=false
    if [[ -d "omni" && -f "omni/OMNI_INTERFACE_SPEC_v0.01.md" ]]; then
      OMNI_PRESENT=true
    fi
    OMNI_STATUS="missing"
    if [[ "$OMNI_PRESENT" == "true" ]]; then
      OMNI_STATUS="available"
    fi

    PLANCK_PRESENT=false
    if [[ -d "planck" && -f "planck/PLANCK_SURFACE_MANAGER_SPEC_v0.01.md" ]]; then
      PLANCK_PRESENT=true
    fi
    PLANCK_STATUS="missing"
    if [[ "$PLANCK_PRESENT" == "true" ]]; then
      PLANCK_STATUS="available"
    fi

    cat <<PROBE_JSON
{
  "spec_version": "v0.01",
  "command": "probe",
  "ok": true,
  "result": {
    "probe": {
      "summary": {
        "omni_present": ${OMNI_PRESENT},
        "omni_status": "${OMNI_STATUS}",
        "planck_present": ${PLANCK_PRESENT},
        "planck_status": "${PLANCK_STATUS}",
        "surface_exec": "blocked"
      },
      "invariants": [
        "no_network",
        "no_execution",
        "deterministic_output"
      ],
      "notes": [
        "dry_run_only"
      ]
    }
  }
}
PROBE_JSON
    exit 0
    ;;

  *)
    # Deterministic usage error
    echo "qtm: unknown command: $cmd" >&2
    echo "qtm: run 'qtm --help' for usage" >&2
    exit 2
    ;;
esac
